import sys
import os
import time
import requests
from openpyxl import Workbook
from datetime import datetime
from PyQt5.QtGui import QFont
from PyQt5.QtCore import QThreadPool
from configparser import ConfigParser
from PyQt5.QtWidgets import QApplication, QMessageBox, QFileDialog, QDateTimeEdit, QTabWidget
from PyQt5.QtCore import QRunnable, pyqtSignal, QObject, QStandardPaths
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QLineEdit, QPushButton


class WorkerSignals(QObject):
    finished = pyqtSignal(str)


class DataWorker(QRunnable):
    finished = pyqtSignal(str)

    def __init__(self, user_id, signals, ht, port, code, token, zjm):
        super().__init__()
        self.user_id = user_id
        self.signals = signals
        self.ht = ht
        self.port = port
        self.code = code
        self.token = token
        self.zjm = zjm

    def run(self):
        headers = {
            'Accept': 'application/json, text/plain, */*',
            'Accept-Encoding': 'gzip, deflate',
            'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
            'Connection': 'keep-alive',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Cookie': f'token={self.token}',
            'User-Agent': self.zjm,
        }

        url = f"http://{self.ht}.boinht.com:{self.port}/user/pf_list_with_game"

        data = {
            "game_user_id": self.user_id,
            "page_size": 32,
            "page": 1,
            "login_code": self.code,
        }

        for attempt in range(10):
            try:
                response = requests.post(url, data=data, headers=headers)
                response.raise_for_status()
                result = response.json().get('result', [])
                if result:
                    for dd in result:
                        APPID = dd.get('app_user_id', '无数据')
                        output = f"{self.user_id}, {APPID}"
                    break
                else:
                    output = f"{self.user_id}, 无数据"
                break
            except requests.exceptions.HTTPError as e:
                if response.status_code == 502 and attempt < 9:
                    time.sleep(5)
                else:
                    output = f"{self.user_id}, 错误: {str(e)}"
                    continue
            except Exception as e:
                output = f"{self.user_id}, 错误: {str(e)}"
                break

        print(output)
        self.signals.finished.emit(output)


class UserWindow(QWidget):
    def __init__(self):
        super().__init__()

        # 设置允许使用的截止时间 (YYYY-MM-DD HH:MM:SS)
        self.expiration_date_str = "2027-04-10 23:59:59"  # 软件过期时间
        self.expiration_date = datetime.strptime(self.expiration_date_str, "%Y-%m-%d %H:%M:%S")

        # 检查是否需要提醒
        remaining_days = self.get_remaining_days()
        if remaining_days > 0 and remaining_days <= 7:
            QMessageBox.warning(self, "软件即将到期", f"本软件将在{remaining_days}天后到期：\n请联系《富贵》获取最新版本。")

        # 检查是否过期
        if self.is_expired():
            QMessageBox.critical(self, "软件已过期", f"本软件的使用期限已过期：\n请联系《富贵》获取最新版本。")
            sys.exit(0)  # 退出程序

        self.setWindowTitle("id转换器__版本20250210")
        self.setGeometry(700, 100, 500, 700)

        # 创建一个标签页
        self.tab_widget = QTabWidget(self)

        # 配置标签
        self.config_tab = QWidget()
        self.setup_config_tab()

        # 数据处理标签
        self.data_tab = QWidget()
        self.setup_data_tab()

        self.tab_widget.addTab(self.data_tab, "首页")
        self.tab_widget.addTab(self.config_tab, "设置")
        self.tab_widget.setFont(QFont("Arial", 15))

        # 主布局
        layout = QVBoxLayout()
        layout.addWidget(self.tab_widget)
        self.setLayout(layout)

        self.thread_pool = QThreadPool()
        self.thread_pool.setMaxThreadCount(1)
        self.completed_tasks = []
        self.user_ids = []

        # 加载配置
        self.load_config()

    def is_expired(self):
        """检查当前时间是否超过指定的截止时间"""
        current_time = datetime.now()  # 获取当前系统时间
        return current_time > self.expiration_date

    def get_remaining_days(self):
        """计算距离过期时间还有多少天"""
        current_time = datetime.now()  # 获取当前系统时间
        days_left = (self.expiration_date - current_time).days  # 计算剩余天数
        return days_left  # 返回剩余的天数

    def setup_data_tab(self):
        layout = QVBoxLayout()

        self.file_button = QPushButton("选择文件")
        self.file_button.clicked.connect(self.select_file)
        layout.addWidget(self.file_button)

        self.thread_count_input = QLineEdit(self)
        self.thread_count_input.setPlaceholderText("多开数量 （最低1台 最高限制100台）")
        self.thread_count_input.setFixedHeight(40)
        layout.addWidget(self.thread_count_input)

        self.start_button = QPushButton("开始转换")
        self.start_button.clicked.connect(self.start_processing)
        self.start_button.setEnabled(False)
        layout.addWidget(self.start_button)

        self.export_button = QPushButton("导出数据")
        self.export_button.setEnabled(False)
        self.export_button.clicked.connect(self.export_data)
        layout.addWidget(self.export_button)

        self.data_tab.setLayout(layout)

    def setup_config_tab(self):
        layout = QVBoxLayout()

        self.srk_ht = QLineEdit(self)
        self.srk_ht.setPlaceholderText("后台")
        self.srk_ht.setFixedHeight(40)
        layout.addWidget(self.srk_ht)

        self.srk_port = QLineEdit(self)
        self.srk_port.setPlaceholderText("port")
        self.srk_port.setFixedHeight(40)
        layout.addWidget(self.srk_port)

        self.srk_token = QLineEdit(self)
        self.srk_token.setPlaceholderText("Cookie")
        self.srk_token.setFixedHeight(40)
        layout.addWidget(self.srk_token)

        self.srk_code = QLineEdit(self)
        self.srk_code.setPlaceholderText("小明登录码")
        self.srk_code.setFixedHeight(40)
        layout.addWidget(self.srk_code)

        self.srk_zjm = QLineEdit(self)
        self.srk_zjm.setPlaceholderText("User-Agent")
        self.srk_zjm.setFixedHeight(40)
        layout.addWidget(self.srk_zjm)

        self.save_button = QPushButton("保存配置")
        self.save_button.clicked.connect(self.manual_save)
        layout.addWidget(self.save_button)

        self.config_tab.setLayout(layout)

    def select_file(self):
        desktop_path = QStandardPaths.writableLocation(QStandardPaths.DesktopLocation)  # 获取桌面路径
        file_name, _ = QFileDialog.getOpenFileName(self, "选择用户ID文件", desktop_path,
                                                   "Text Files (*.txt);;All Files (*)")
        if file_name:
            error_lines = []  # 用于记录包含非数字字符的行号
            self.user_ids = []  # 清空之前的用户ID列表

            try:
                with open(file_name, 'r', encoding='utf-8') as file:  # 使用utf-8编码打开文件
                    for line_number, line in enumerate(file, start=1):  # 逐行读取文件
                        line = line.strip()  # 去除空白字符
                        if line:  # 如果行不为空
                            if line.isdigit():  # 检查是否为纯数字
                                self.user_ids.append(line)  # 如果是数字，添加到用户ID列表
                            else:
                                error_lines.append(line_number)  # 记录错误行号

                if error_lines:
                    # 如果有错误行，提示用户
                    error_message = f"文件中有非数字字符，错误行号：{', '.join(map(str, error_lines))}"
                    QMessageBox.warning(self, "错误", error_message)
                else:
                    # 如果没有错误，提示加载成功
                    QMessageBox.information(self, "提示", f"已加载 {len(self.user_ids)} 个用户ID！")
                    self.start_button.setEnabled(True)

            except UnicodeDecodeError:
                # 如果文件编码错误，提示用户
                QMessageBox.warning(self, "错误", "文件编码错误，请确保文件使用UTF-8编码！")

    def start_processing(self):
        self.completed_tasks = []
        ht = self.srk_ht.text()
        port = self.srk_port.text()
        code = self.srk_code.text()
        token = self.srk_token.text()
        zjm = self.srk_zjm.text()

        if not ht or not port or not code or not token:
            QMessageBox.warning(self, "输入错误", "请确保所有配置输入框都已填写！")
            return

        # 获取用户输入的线程数量
        thread_count = self.thread_count_input.text()
        if thread_count.isdigit() and int(thread_count) > 0:
            max_threads = min(int(thread_count), 200)  # 限制线程数量最高为200
            self.thread_pool.setMaxThreadCount(max_threads)
        else:
            QMessageBox.warning(self, "输入错误", "请确保多开数量为正整数！")
            return

        # 锁定按钮代码
        self.start_button.setEnabled(False)
        self.export_button.setEnabled(False)

        for user_id in self.user_ids:
            signals = WorkerSignals()
            signals.finished.connect(self.task_finished)
            worker = DataWorker(user_id, signals, ht, port, code, token, zjm)
            self.thread_pool.start(worker)

    def task_finished(self, result):
        self.completed_tasks.append(result)
        if len(self.completed_tasks) == len(self.user_ids):
            QMessageBox.information(self, "提示", "所有数据已获取完成！")
            # 解锁按钮
            self.start_button.setEnabled(True)
            self.export_button.setEnabled(True)

    def export_data(self):
        try:
            wb = Workbook()
            ws = wb.active
            ws.append(['游戏ID', 'APPID'])

            for task in self.completed_tasks:
                parts = task.split(", ")
                user_id = parts[0]
                phone_number = parts[1] if len(parts) > 1 else "无数据"
                ws.append([user_id, phone_number])

            # 使用当前时间作为文件名
            current_time = datetime.now().strftime("%Y年%m月%d日%H时%M分%S秒")
            filename = f"用户数据_{current_time}.xlsx"
            wb.save(filename)
            QMessageBox.information(self, "提示", f"数据已导出到 {filename}")

            # 打开生成的 Excel 文件
            os.startfile(filename)

        except Exception as e:
            QMessageBox.critical(self, "导出错误", f"导出数据时发生错误: {str(e)}")

    def convert_to_number(self, value):
        try:
            return float(value)  # 尝试将值转换为浮点数
        except ValueError:
            return "无数据"  # 转换失败时返回"无数据"

    def save_config(self, ht, port, token, code, zjm):  # 保存配置到文件
        config = ConfigParser()
        config['USER'] = {'ht': ht, 'Port': port, 'Token': token, 'Code': code, 'zjm': zjm}
        with open('config.ini', 'w') as configfile:
            config.write(configfile)

    def load_config(self):  # 从文件加载配置
        config = ConfigParser()
        config.read('config.ini')
        if 'USER' in config:
            self.srk_ht.setText(config['USER']['ht'])
            self.srk_port.setText(config['USER']['port'])
            self.srk_token.setText(config['USER']['Token'])
            self.srk_code.setText(config['USER']['Code'])
            self.srk_zjm.setText(config['USER']['zjm'])

    def manual_save(self):  # 手动保存函数  port
        ht = self.srk_ht.text()
        port = self.srk_port.text()
        token = self.srk_token.text()
        code = self.srk_code.text()
        zjm = self.srk_zjm.text()
        if ht and port and token and code and zjm:
            self.save_config(ht, port, token, code, zjm)
            QMessageBox.information(self, "提示", "配置已保存！")
        else:
            QMessageBox.warning(self, "警告", "请填写完整的配置！")


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = UserWindow()
    window.show()
    sys.exit(app.exec_())
